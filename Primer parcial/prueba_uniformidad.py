# -*- coding: utf-8 -*-
"""prueba_uniformidad.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Z81LUPrPc7fb9_MBYfSTb31mbvyrXCq3

Funcion para determinar prueba de uniformidad de una lista de numeros (n>=30)
"""

def FO_n(D,li,ls,n):
  Fo=[]    
  for x in range(n):    
    if D[x] >= li:    
      if D[x] <= ls:
        Fo.append(D[x])
  d=len(Fo)
  return(d)

import numpy as np
import math as mt
import scipy.stats as sst

D =     [0.78,0.98,0.24,0.73,0.43,0.16,0.78,0.47,0.18,0.55]
D = D + [0.04,0.29,0.68,0.77,0.16,0.03,0.79,0.22,0.37,0.80]
D = D + [0.96,0.26,0.91,0.55,0.75,0.55,0.64,0.39,0.53,0.45]
D = D + [0.61,0.14,0.38,0.12,0.40,0.74,0.78,0.98,0.27,0.60]
D = D + [0.43,0.67,0.62,0.32,0.53,0.54,0.24,0.29,0.18,0.08]
D = D + [0.82,0.94,0.19,0.98,0.41,1.00,0.74,0.92,0.14,0.43]
D = D + [0.83,0.88,0.18,0.21,0.50,0.13,0.43,0.69,0.08,0.12]
D = D + [0.22,0.50,0.16,0.11,0.18,0.89,0.80,0.42,0.29,0.87]
D = D + [0.83,0.79,0.65,0.28,0.78,0.49,0.36,0.86,0.87,0.64]
D = D + [0.51,0.07,0.18,0.94,0.50,0.22,0.66,0.91,0.48,0.24]
n=len(D)

'''d =     [0.8797,0.3884,0.6289,0.8750,0.5999,0.8589,0.9996,0.2415,0.3808,0.9606]
d = d + [0.9848,0.3469,0.7977,0.5844,0.8147,0.6431,0.7387,0.5613,0.0318,0.7401]
d = d + [0.4557,0.1592,0.8536,0.8846,0.3410,0.1492,0.8681,0.5291,0.3188,0.5992]
d = d + [0.9170,0.2204,0.5991,0.5461,0.5739,0.3254,0.0856,0.2258,0.4603,0.5027]
d = d + [0.8376,0.6235,0.3681,0.2088,0.1525,0.2006,0.4720,0.4272,0.6360,0.0954]'''

D.sort()
# Calculos para la construccion de la tabla de distribucion de frecuencia
Rango = max(D) - min(D)
k=round(mt.sqrt(len(D)))
Amplitud=round(Rango/k,3)
Precalculo = round(min(D) + k*Amplitud,2)
comparacion = round(Precalculo - max(D),10);

if np.mod(comparacion,2)==0:
  comparacion = comparacion/2 

liminf = min(D) - comparacion


#Calculo de la tabla de distribucion de frecuencias
D1=np.array(D)
T=np.zeros((k,4))
for x in range(k):
  
  T[x][0]=liminf

  liminf = round(liminf + Amplitud,3);
  T[x][1]=liminf

  T[x][2]=FO_n(D,T[x][0],T[x][1],n)

  T[x][3]=100*(T[x][1]-T[x][0])/Rango
print('Tabla de distribucion de frecuencias')
print(T,'\n')

C=0
for x in range(k):
  C = C + mt.pow(10-T[x][2],2)
C = C/k
print('Valor de C (estadistico de prueba)')
print('C = ',C,'\n')

X_2 = sst.chi2.ppf(0.90,9)
print('El valor del punto critico es')
print('X_2(0.10,9) = ',X_2)

print('\nsi C <= X_2')
print('La prueba es',C<X_2)

"""Funcion para contar frecuencias observadas

"""